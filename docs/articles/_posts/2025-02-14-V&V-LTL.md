---
layout: post
title: V&V-Linear Temporal Logic
truncated_preview: true
excerpt_separator: <!--more-->
tags:
  - miscellaneous
categories: article
---
<!--more-->

# Linear Temporal Logic (LTL)
Ancora una volta introduciamo un modello che serve per rappresentare qualcosa in modo formale, permettendoci di maneggiarne proprietÃ  e risultati. 

In questo caso il modello che introduciamo Ã¨ il modello LTL che serve a rappresentare il tempo, visto come una sequenza di istanti.

Il modello da cui partiremo Ã¨ il modello PLTL(Propositional Linear Temporal Logic), ma ne esistono di altri tipi che chi Ã¨ interessato puÃ² trovare in fondo all'articolo.

## Propositional Linear Temporal Logic
Di seguito introdurrÃ² i mattoncini di base per comprendere questo modello e iniziare a utilizzarlo, per cui introdurrÃ² 
- la sintassi di base
- le varie abbreviazioni che si possono usare
- le strutture presenti
- la semantica 

### Sintassi

La sintassi di PLTL Ã¨ piuttosto semplice. Abbiamo:
- lettere proposizionali
  - maiuscole: indicano proposizioni
  - minuscole: indicano variabili proposizionali generiche
- connettori *logici*: $\to, \land, \lor, \lnot$
- connettori *temporali*:
  - $X$ = ne**X**t = istante immediatamente successivo
    - $Xp$ significa che p Ã¨ vero nell'istante immediatamente successivo
  - $U$ = **U**ntil 
    - $p\;Uq$ significa che p Ã¨ vero almeno fintanto che q non diventa vero 
- formule: si formano a partire dalle lettere proposizionali e i congiuntivi temporali e logici

#### ðŸ‘ï¸ Attenzione, esistono piÃ¹ versioni di Until
Non esiste solo una versione della proposizione Until, bensÃ¬ 4:

| versione | notazione | significato | 
| :---: | :---:| :---: |
| strong until | $p U_\exists q$
| weak until | $p U_\forall q$
| strict until |$p U^\ge q | 
| non-strict until | $p U^\gt q| 

### Abbreviazioni
Per evitare di scrivere formule un sacco lunghe, possiamo usare le abbreviazioni seguenti:

|abbreviazione|versione estesa|significato|
|:---:|:---:|:---:|
|$Fp$ | $\text{true } U p$ | eventually, ossia prima o poi p diventa vero|
|$Gp$|$\lor F \lor p$| alway, ossia p Ã¨ sempre vero|
|$F^{\infty}p$|$GFp$|infinite volte, ossia p diventa vero infinite volte nel futuro|
|$pBq$|$\lor((\lor p)U q)$|$p$ prima di $q$, ossia q Ã¨ vero solo se prima si Ã¨ verificato p|


### Strutture
In PLTL potremmo vedere la struttura/modello seguente:

$$
M:(S,x,L)
$$

In cui:
- S Ã¨ l'insieme degli stati
- x Ã¨ una sequenza infinita di stati tale che $x\in S^{\omega}$

$$
x = x(0),x(1),..., x(i), x(i+1), ...
$$

- L Ã¨ la funzione di labeling tale che

$$
L: x \to 2^{AP}\;\;\;\;\;\;\; \text{AP Ã¨ l'insieme delle lettere proposizionali}
$$

Possiamo vedere un modello $M$ come:
- l'insieme degli stati (o configurazioni) di un sistema 
- la sequenza infinita di stati x che rappresenta una specifica esecuzione del sistema
- la funzione L che indica quali proprietÃ  sono vere in ogni stato.


### Semantica 
Se vedete scritte cose tipo 

$$
M,x \models p
$$

dovete interpretarlo come *"$p$ Ã¨ vero in $M$ all'istante $x(0)$"*.
Vi potreste chiedere: ma perchÃ¨ se c'Ã¨ scritto $x$ noi lo vediamo come $x(0)$? BÃ¨, perchÃ¨ Ã¨ una questione di notazione. Ad esempio per indicare "ogni istante di tempo" scriviamo $x^i$ 

$$
\forall i=0,1,.., \; \text{ sia } x^i =(s_i, s_{i+1},...)
$$

in patciolare $x = s_0 = x(0)$


### Teorema di Kamp
Il frammento di prim'ordine di S1S Ã¨ equivalente a LTL con strict-strong until, perciÃ² LTL ha la stessa potenza espressiva delle espressioni $\omega$-regolari. 


## Tableau-based decision procedure
>La tableau-based decision procedure per la Linear Temporal Logic (LTL) Ã¨ un metodo automatico per verificare la soddisfacibilitÃ  di una formula LTL, ossia determinare se esiste almeno un modello che la rende vera.

Prima di spiegare come funziona la procedura di decisione tableu-based, abbiamo bisogno di introdurre alcuni concetti:
- cos'Ã¨ la **$\varphi$-chiusura** su $\varphi$
- cosa si intende per **$\varphi$-atomo**

### $\varphi$-chiusura
A partire da una formula $\varphi$ Ã¨ possibile definire la sua $\varphi$-chiusura come l'insieme composto da 
- $\varphi$ e $\lnot \varphi$
- tutte le sottoformule di $\varphi$
- la negazione di tutti gli elementi dell'insieme
- per tutti i $\psi \in \{Gp, Fp, pUq\}$ viene aggiunto $X\psi$   

Indichiamo questo insieme come $\phi_\varphi$ (si pronuncia "phi di varphi").

### $\varphi$-atomo
Un $\varphi$-atomo lo definisco come un insieme $A$ sottoinsieme di $\phi_\varphi$ che soddisfa queste proprietÃ :
- non ci devono essere conflitti tra gli elementi di $A$
  - quindi ovviamente solo uno tra $p$ e $\lnot p$ puÃ² stare in $A$
- $\forall$ $\alpha$-formula $\in A$ , tutte le scoposizioni $k_\alpha$ devono appartenere ad $A$ 
- $\forall$ $\beta$-formula $\in A$ , almeno una delle due scoposizioni $k_\beta^{(1)}, k_\beta^{(2)}$ devono appartenere ad $A$ 


|$\alpha$-formula| $k_\alpha$ |
|:--:|:--:|
|$p\land q$ |$p,q$|
|$Gp$|$p,XGp$|

|$\beta$-formula| $k_\beta^{(1)}$ | $k_\beta^{(2)}$|
|:--:|:--:|:--:|
|$p\lor q$|$p$|$q$|
|$Fp$|$p$|$XFp$|
|$pUq$|$q$|$X(pUq)$|


Un qualsiasi sottoinsieme di $\phi_\varphi$ si dice **mutualmente soddisfacibile** se esiste un modello $\sigma$ e una posizione $j\ge$ 0 tale che ogni elemento dell'insieme vale in posizione $j$ (praticamente Ã¨ un po' come dire che un insieme di proprietÃ  Ã¨ vera all'istante $j$). 

Attenzione, non ho detto che il generico sottoinsieme Ã¨ una $\varphi$-formula, ho solo detto che Ã¨ un sottoinsieme di $\phi_\varphi$. Difatti per ogni insieme mutualmente soddisfacibile esiste una $\varphi$-formula $A$ tale che $A \subset \phi_\varphi$.



### Tableau method
Il metodo dei tableau prevede questi passaggi:
1. ricavo tutti i $\varphi$-atomi e assegno un nodo a ciascuno 
2. connetto i nodi A e B se e solo se per ogni $Xp \in \phi_\varphi$ , $Xp \in A$ sse $p \in B$. (quindi essenzialmente guardo $A$ e per ogni formula del tipo $Xp$ cerco il corrispettivo $p$ in $B$) 

PerciÃ² seguendo il nostro ragionamento, se $\varphi = Gp \land F\lnot p$ il tableau corrispondente sarÃ :

![](/assets/images/tableau.png)


### Cammino indotto
---

## Others LTL models

#### Quantified LTL (QLTL)
- Aggiunge quantificatori sulle lettere proposizionali.

- Permette di esprimere proprietÃ  su insiemi di mondi possibili.
- Le lettere proposizionali possono essere quantificate esistenzialmente ($\exists p$) o universalmente ($\forall p$).

*Esempio*:

$$
\forall p.G(p\to Xp)
$$

Significa: "per ogni proposizione $p$, se $p$ Ã¨ vera, rimarrÃ  vera nel prossimo istante".

ðŸ“Œ Applicazione: Verifica di sistemi con variabili non completamente specificate.

--- 
#### First-Order Linear Temporal Logic (FO-LTL)

- Estende LTL con quantificatori su variabili individuali

- Aggiunge quantificatori âˆ€xâˆ€x, âˆƒxâˆƒx e relazioni tra variabili.
-  PuÃ² esprimere proprietÃ  piÃ¹ complesse rispetto a PLTL.

*Esempio*:

$$ 
\forall x.(P(x)\to XP(f(x)))
$$

Significa: "per ogni elemento xx, se ha la proprietÃ  PP, allora anche la sua trasformazione f(x)f(x) la avrÃ  nel prossimo stato".

ðŸ“Œ Applicazione: Verifica di modelli con strutture dati infinite.


---
#### Probabilistic LTL (PLTL o PCTL)*

- Aggiunge operatori probabilistici

- Consente di esprimere la probabilitÃ  che un evento si verifichi.
- Si usa nei modelli stocastici.

*Esempio*:

$$
P_{>0.9}(F_{\text{success}})
$$

Significa: "la probabilitÃ  che l'evento 'success' accada eventualmente Ã¨ maggiore di 0.9".

ðŸ“Œ Applicazione: Verifica di sistemi probabilistici, come protocolli di rete o AI.


---
#### Metric Temporal Logic (MTL)

- Estende LTL con vincoli temporali espliciti

- Aggiunge intervalli di tempo sugli operatori.

*Esempio*:

$$
F_{[2,5]}p
$$

Significa: "$p$ diventerÃ  vero tra 2 e 5 unitÃ  di tempo nel futuro".

ðŸ“Œ Applicazione: Sistemi real-time, controllo industriale.


---
#### Linear-Time $\mu$-Calculus

- Aggiunge operatori di "fissaggio di punto" per definire proprietÃ  ricorsive.

- Si usa per descrivere pattern di comportamento infiniti.

*Esempio*:

$$
\mu X.(p\lor X)
$$

Significa: "$p$ sarÃ  vero per sempre o ciclicamente ripetuto".

ðŸ“Œ Applicazione: Verifica di sistemi con looping o ricorsione.
