---
layout: post
title: V&V-Linear Temporal Logic
truncated_preview: true
excerpt_separator: <!--more-->
tags:
  - miscellaneous
categories: article
---
<!--more-->

# Linear Temporal Logic (LTL)
Ancora una volta introduciamo un modello che serve per rappresentare qualcosa in modo formale, permettendoci di maneggiarne proprietà e risultati. 

In questo caso il modello che introduciamo è il modello LTL che serve a rappresentare il tempo, visto come una sequenza di istanti.

Il modello da cui partiremo è il modello PLTL(Propositional Linear Temporal Logic), ma ne esistono di altri tipi che chi è interessato può trovare in fondo all'articolo.

## Propositional Linear Temporal Logic
Di seguito introdurrò i mattoncini di base per comprendere questo modello e iniziare a utilizzarlo, per cui introdurrò 
- la sintassi di base
- le varie abbreviazioni che si possono usare
- le strutture presenti
- la semantica 

### Sintassi

La sintassi di PLTL è piuttosto semplice. Abbiamo:
- lettere proposizionali
  - maiuscole: indicano proposizioni
  - minuscole: indicano variabili proposizionali generiche
- connettori *logici*: $\to, \land, \lor, \lnot$
- connettori *temporali*:
  - $X$ = ne**X**t = istante immediatamente successivo
    - $Xp$ significa che p è vero nell'istante immediatamente successivo
  - $U$ = **U**ntil 
    - $p\;Uq$ significa che p è vero almeno fintanto che q non diventa vero 
- formule: si formano a partire dalle lettere proposizionali e i congiuntivi temporali e logici

#### 👁️ Attenzione, esistono più versioni di Until
Non esiste solo una versione della proposizione Until, bensì 4:

| versione | notazione | significato | 
| :---: | :---:| :---: |
| strong until | $p U_\exists q$
| weak until | $p U_\forall q$
| strict until |$p U^\ge q | 
| non-strict until | $p U^\gt q| 

### Abbreviazioni
Per evitare di scrivere formule un sacco lunghe, possiamo usare le abbreviazioni seguenti:

|abbreviazione|versione estesa|significato|
|:---:|:---:|:---:|
|$Fp$ | $\text{true } U p$ | eventually, ossia prima o poi p diventa vero|
|$Gp$|$\lor F \lor p$| alway, ossia p è sempre vero|
|$F^{\infty}p$|$GFp$|infinite volte, ossia p diventa vero infinite volte nel futuro|
|$pBq$|$\lor((\lor p)U q)$|$p$ prima di $q$, ossia q è vero solo se prima si è verificato p|


### Strutture
In PLTL potremmo vedere la struttura/modello seguente:

$$
M:(S,x,L)
$$

In cui:
- S è l'insieme degli stati
- x è una sequenza infinita di stati tale che $x\in S^{\omega}$

$$
x = x(0),x(1),..., x(i), x(i+1), ...
$$

- L è la funzione di labeling tale che

$$
L: x \to 2^{AP}\;\;\;\;\;\;\; \text{AP è l'insieme delle lettere proposizionali}
$$

Possiamo vedere un modello $M$ come:
- l'insieme degli stati (o configurazioni) di un sistema 
- la sequenza infinita di stati x che rappresenta una specifica esecuzione del sistema
- la funzione L che indica quali proprietà sono vere in ogni stato.


### Semantica 
Se vedete scritte cose tipo 

$$
M,x \models p
$$

dovete interpretarlo come *"$p$ è vero in $M$ all'istante $x(0)$"*.
Vi potreste chiedere: ma perchè se c'è scritto $x$ noi lo vediamo come $x(0)$? Bè, perchè è una questione di notazione. Ad esempio per indicare "ogni istante di tempo" scriviamo $x^i$ 

$$
\forall i=0,1,.., \; \text{ sia } x^i =(s_i, s_{i+1},...)
$$

in patciolare $x = s_0 = x(0)$


### Teorema di Kamp
Il frammento di prim'ordine di S1S è equivalente a LTL con strict-strong until, perciò LTL ha la stessa potenza espressiva delle espressioni $\omega$-regolari. 


## Tableau-based decision procedure
>La tableau-based decision procedure per la Linear Temporal Logic (LTL) è un metodo automatico per verificare la soddisfacibilità di una formula LTL, ossia determinare se esiste almeno un modello che la rende vera.

Prima di spiegare come funziona la procedura di decisione tableu-based, abbiamo bisogno di introdurre alcuni concetti:
- cos'è la **$\varphi$-chiusura** su $\varphi$
- cosa si intende per **$\varphi$-atomo**

### $\varphi$-chiusura
A partire da una formula $\varphi$ è possibile definire la sua $\varphi$-chiusura come l'insieme composto da 
- $\varphi$ e $\lnot \varphi$
- tutte le sottoformule di $\varphi$
- la negazione di tutti gli elementi dell'insieme
- per tutti i $\psi \in \{Gp, Fp, pUq\}$ viene aggiunto $X\psi$   

Indichiamo questo insieme come $\phi_\varphi$ (si pronuncia "phi di varphi").

### $\varphi$-atomo
Un $\varphi$-atomo lo definisco come un insieme $A$ sottoinsieme di $\phi_\varphi$ che soddisfa queste proprietà:
- non ci devono essere conflitti tra gli elementi di $A$
  - quindi ovviamente solo uno tra $p$ e $\lnot p$ può stare in $A$
- $\forall$ $\alpha$-formula $\in A$ , tutte le scoposizioni $k_\alpha$ devono appartenere ad $A$ 
- $\forall$ $\beta$-formula $\in A$ , almeno una delle due scoposizioni $k_\beta^{(1)}, k_\beta^{(2)}$ devono appartenere ad $A$ 


|$\alpha$-formula| $k_\alpha$ |
|:--:|:--:|
|$p\land q$ |$p,q$|
|$Gp$|$p,XGp$|

|$\beta$-formula| $k_\beta^{(1)}$ | $k_\beta^{(2)}$|
|:--:|:--:|:--:|
|$p\lor q$|$p$|$q$|
|$Fp$|$p$|$XFp$|
|$pUq$|$q$|$X(pUq)$|


Un qualsiasi sottoinsieme di $\phi_\varphi$ si dice **mutualmente soddisfacibile** se esiste un modello $\sigma$ e una posizione $j\ge$ 0 tale che ogni elemento dell'insieme vale in posizione $j$ (praticamente è un po' come dire che un insieme di proprietà è vera all'istante $j$). 

Attenzione, non ho detto che il generico sottoinsieme è una $\varphi$-formula, ho solo detto che è un sottoinsieme di $\phi_\varphi$. Difatti per ogni insieme mutualmente soddisfacibile esiste una $\varphi$-formula $A$ tale che $A \subset \phi_\varphi$.



### Tableau method
Il metodo dei tableau prevede questi passaggi:
1. ricavo tutti i $\varphi$-atomi e assegno un nodo a ciascuno 
2. connetto i nodi A e B se e solo se per ogni $Xp \in \phi_\varphi$ , $Xp \in A$ sse $p \in B$. (quindi essenzialmente guardo $A$ e per ogni formula del tipo $Xp$ cerco il corrispettivo $p$ in $B$) 

Perciò seguendo il nostro ragionamento, se $\varphi = Gp \land F\lnot p$ il tableau corrispondente sarà:

![](/assets/images/tableau.png)


### Cammino indotto
---

## Others LTL models

#### Quantified LTL (QLTL)
- Aggiunge quantificatori sulle lettere proposizionali.

- Permette di esprimere proprietà su insiemi di mondi possibili.
- Le lettere proposizionali possono essere quantificate esistenzialmente ($\exists p$) o universalmente ($\forall p$).

*Esempio*:

$$
\forall p.G(p\to Xp)
$$

Significa: "per ogni proposizione $p$, se $p$ è vera, rimarrà vera nel prossimo istante".

📌 Applicazione: Verifica di sistemi con variabili non completamente specificate.

--- 
#### First-Order Linear Temporal Logic (FO-LTL)

- Estende LTL con quantificatori su variabili individuali

- Aggiunge quantificatori ∀x∀x, ∃x∃x e relazioni tra variabili.
-  Può esprimere proprietà più complesse rispetto a PLTL.

*Esempio*:

$$ 
\forall x.(P(x)\to XP(f(x)))
$$

Significa: "per ogni elemento xx, se ha la proprietà PP, allora anche la sua trasformazione f(x)f(x) la avrà nel prossimo stato".

📌 Applicazione: Verifica di modelli con strutture dati infinite.


---
#### Probabilistic LTL (PLTL o PCTL)*

- Aggiunge operatori probabilistici

- Consente di esprimere la probabilità che un evento si verifichi.
- Si usa nei modelli stocastici.

*Esempio*:

$$
P_{>0.9}(F_{\text{success}})
$$

Significa: "la probabilità che l'evento 'success' accada eventualmente è maggiore di 0.9".

📌 Applicazione: Verifica di sistemi probabilistici, come protocolli di rete o AI.


---
#### Metric Temporal Logic (MTL)

- Estende LTL con vincoli temporali espliciti

- Aggiunge intervalli di tempo sugli operatori.

*Esempio*:

$$
F_{[2,5]}p
$$

Significa: "$p$ diventerà vero tra 2 e 5 unità di tempo nel futuro".

📌 Applicazione: Sistemi real-time, controllo industriale.


---
#### Linear-Time $\mu$-Calculus

- Aggiunge operatori di "fissaggio di punto" per definire proprietà ricorsive.

- Si usa per descrivere pattern di comportamento infiniti.

*Esempio*:

$$
\mu X.(p\lor X)
$$

Significa: "$p$ sarà vero per sempre o ciclicamente ripetuto".

📌 Applicazione: Verifica di sistemi con looping o ricorsione.
